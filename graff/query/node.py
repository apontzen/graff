from .base import *

class GenericNodeQuery(BaseQuery):
    """Represents a query that returns nodes of a specific category or all categories"""

    _user_query_returns_self = True
    # if True, a call to all() returns this node (plus any other columns asked for)
    # if False, a call to all() does not return this node, only the other columns

    def __init__(self, graph_connection):
        super(GenericNodeQuery, self).__init__(graph_connection)

        if self._user_query_returns_self:
            self._tt_current_location_id = self._temp_table_state.add_column("node_id", Integer, ForeignKey('nodes.id'),
                                                                     query_callback = self._node_query_callback)
        else:
            self._tt_current_location_id = self._temp_table_state.add_column("noreturn_node_id", Integer, ForeignKey('nodes.id'),
                                                                     query_callback = self._null_query_callback)

    @classmethod
    def _null_query_callback(cls, column):
        return None, None, None

    @classmethod
    def _node_query_callback(cls, column):
        alias = aliased(orm.Node)
        return alias, alias, (alias.id==column)

    def return_property(self, *args):
        """Return a query that returns properties"""
        return NodeNamedPropertiesQuery(self, *args)

    def return_properties(self):
        return NodeAllPropertiesQuery(self)

    def return_this(self, *args):
        """Return a query that returns this node"""
        return PersistentNodeQuery(self)

    def filter(self, condition):
        """Return a new graph query that represents the old one filtered by a stated condition"""
        return NodeFilterNamedPropertiesQuery(self, condition)

    def follow(self, category=None):
        """Return a query that follows an edge to the next node.

        The edge may fall into a named category; or if None, all possible edges are followed.

        Note that the q.follow(category) is equivalent to, but more efficient than, q.edge(category).node()"""
        return FollowQuery(self, category)

    def edge(self, category=None):
        """Return a query that returns all edges from this node.

        The edges may fall into a named category; or if None, all possible edges are returned."""
        from . import edge
        return edge.EdgeQueryFromNodeQuery(self, category)


class NodeQuery(GenericNodeQuery):
    def __init__(self, graph_connection, category_=None):
        super(NodeQuery, self).__init__(graph_connection)
        self._set_category(category_)

    def _get_populate_temp_table_statement(self):
        orm_query = self._session.query(orm.Node.id).filter_by(category_id=self._category)
        insert_statement = self.get_temp_table().insert().from_select([self._tt_current_location_id], orm_query)
        return insert_statement


class NodeQueryFromUnderlyingQuery(GenericNodeQuery, QueryFromUnderlyingQuery):
    pass


class NodeQueryFromNodeQuery(NodeQueryFromUnderlyingQuery):
    """Represents a query that returns nodes based on a previous set of nodes in an underlying 'base' query"""
    def __init__(self, base):
        assert isinstance(base, GenericNodeQuery)
        super(NodeQueryFromNodeQuery, self).__init__(base)


class PersistentNodeQuery(PersistentQuery, NodeQueryFromNodeQuery):
    _user_query_returns_self = False # don't also return the transient node column
    _persistent_query_callback = NodeQueryFromNodeQuery._node_query_callback
    _persistent_postprocess_callback = None

    _node_or_edge = 'node'
    _node_or_edge_orm = orm.Node
    _property_orm = orm.NodeProperty


class FollowQuery(NodeQueryFromNodeQuery):
    """Represents a query that returns nodes linked by edges to the previous nodes.

    The edges may fall into a particular category, or if no category is specified all edges are followed."""

    def __init__(self, base, category):
        super(FollowQuery, self).__init__(base)
        self._set_category(category)

    def _get_populate_temp_table_statement(self):
        prev_table = self._base.get_temp_table()
        query = self._session.query(orm.Edge.node_to_id, *self._copy_columns_source)\
            .select_from(prev_table)\
            .outerjoin(orm.Edge, orm.Edge.node_from_id == self._base._tt_current_location_id)
        # outer join to capture multiple edges; but will later filter to remove NULL entries

        if self._category:
            query = query.filter(orm.Edge.category_id == self._category)
        insert_statement = self.get_temp_table().insert().from_select([self._tt_current_location_id] + self._copy_columns_target, query)
        return insert_statement

    def _filter_temp_table(self):
        # Remove NULL entries generated by outer join above
        tt = self.get_temp_table()
        self._connection.execute(tt.delete().where(self._tt_current_location_id == None))

class NodeAllPropertiesQuery(AllPropertiesQuery, NodeQueryFromNodeQuery):
    _node_or_edge = 'node'
    _node_or_edge_orm = orm.Node
    _property_orm = orm.NodeProperty

class NodeQueryWithValuesForInternalUse(QueryWithValuesForInternalUse, NodeQueryFromNodeQuery):
    _node_or_edge = 'node'
    _node_or_edge_orm = orm.Node
    _property_orm = orm.NodeProperty


class NodeNamedPropertiesQuery(NamedPropertiesQuery, NodeQueryWithValuesForInternalUse):
    """Represents a query that returns the underlying nodes, plus named properties of those nodes.

    The properties are returned as columns, i.e. each named category generates a column that in turn has the
    value of the node's property. The row count is unchanged from the underlying query."""
    pass


class NodeFilterNamedPropertiesQuery(FilterNamedPropertiesQuery, NodeQueryWithValuesForInternalUse):
    """Represents a query that returns the underlying nodes, filtered by a condition that relies on named properties.

    Note that the properties are not returned to the user."""
    pass